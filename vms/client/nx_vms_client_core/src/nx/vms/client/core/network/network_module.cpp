// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/

#include "network_module.h"

#include <memory>

#include <QtCore/QStandardPaths>

#include <nx/utils/log/assert.h>
#include <nx/utils/serialization/format.h>
#include <nx/utils/thread/mutex.h>
#include <nx/vms/client/core/application_context.h>
#include <nx/vms/client/core/settings/client_core_settings.h>
#include <nx/vms/client/core/system_context.h>

#include "certificate_storage.h"
#include "certificate_verifier.h"
#include "cloud_status_watcher.h"
#include "private/remote_connection_factory_requests.h"
#include "remote_connection.h"
#include "remote_connection_factory.h"
#include "remote_session.h"
#include "remote_session_timeout_watcher.h"
#include "server_certificate_watcher.h"

namespace nx::vms::client::core {

struct NetworkModule::Private
{
    /** Storage for certificates which were actually used for connection. */
    std::unique_ptr<CertificateStorage> connectionCertificatesStorage;

    /** Storage for server auto-generated certificates. */
    std::unique_ptr<CertificateStorage> autoGeneratedCertificatesStorage;

    std::unique_ptr<CertificateVerifier> certificateVerifier;
    std::unique_ptr<RemoteConnectionFactory> connectionFactory;
    std::unique_ptr<ServerCertificateWatcher> serverCertificateWatcher;
    std::shared_ptr<RemoteSession> session;

    QPointer<SystemContext> mainSystemContext;

    mutable nx::Mutex mutex;
};

NetworkModule::NetworkModule(
    QObject* parent)
    :
    base_type(parent),
    d(new Private)
{
    const QString rootCertificatesPath =
        QStandardPaths::writableLocation(QStandardPaths::AppLocalDataLocation) + "/certificates";

    const auto certificateValidationLevel =
        appContext()->coreSettings()->certificateValidationLevel();

    d->connectionCertificatesStorage = std::make_unique<CertificateStorage>(
        rootCertificatesPath + "/connection", certificateValidationLevel);
    d->autoGeneratedCertificatesStorage = std::make_unique<CertificateStorage>(
        rootCertificatesPath + "/autogenerated", certificateValidationLevel);

    d->certificateVerifier = std::make_unique<CertificateVerifier>(
        certificateValidationLevel,
        d->connectionCertificatesStorage.get(),
        d->autoGeneratedCertificatesStorage.get());

    RemoteConnectionFactory::CloudCredentialsProvider cloudCredentialsProvider;
    cloudCredentialsProvider.getCredentials =
        [] { return qnCloudStatusWatcher->remoteConnectionCredentials(); };
    cloudCredentialsProvider.getLogin =
        [] { return qnCloudStatusWatcher->cloudLogin().toStdString(); };
    cloudCredentialsProvider.getDigestPassword =
        [] { return appContext()->coreSettings()->digestCloudPassword(); };
    cloudCredentialsProvider.is2FaEnabledForUser =
        [] { return qnCloudStatusWatcher->is2FaEnabledForUser(); };

    auto requestsManager = std::make_unique<detail::RemoteConnectionFactoryRequestsManager>(
        d->certificateVerifier.get());

    d->connectionFactory = std::make_unique<RemoteConnectionFactory>(
        std::move(cloudCredentialsProvider),
        std::move(requestsManager),
        d->certificateVerifier.get(),
        appContext()->localPeerType(),
        appContext()->serializationFormat());

    connect(appContext(),
        &ApplicationContext::systemContextAdded,
        [this](SystemContext* systemContext)
        {
            if ((systemContext->mode() != SystemContext::Mode::client
                && systemContext->mode() != SystemContext::Mode::unitTests)
                    || !NX_ASSERT(!d->mainSystemContext))
            {
                return;
            }

            d->mainSystemContext = systemContext;

            systemContext->enableNetworking(d->certificateVerifier.get());
            d->serverCertificateWatcher = std::make_unique<ServerCertificateWatcher>(
                systemContext, d->certificateVerifier.get());
        });

    connect(appContext(),
        &ApplicationContext::systemContextRemoved,
        [this](SystemContext* systemContext)
        {
            if (d->mainSystemContext != systemContext)
                return;

            d->mainSystemContext.clear();

            d->connectionFactory->setUserInteractionDelegate(nullptr);
            setSession(nullptr);
            d->serverCertificateWatcher.reset();
            systemContext->enableNetworking(nullptr);
        });
}

NetworkModule::~NetworkModule()
{
    // Stop running session before network module is completely destroyed.
    NX_MUTEX_LOCKER lock(&d->mutex);
    d->session.reset();
}

std::shared_ptr<RemoteSession> NetworkModule::session() const
{
    NX_MUTEX_LOCKER lock(&d->mutex);
    return d->session;
}

void NetworkModule::setSession(std::shared_ptr<RemoteSession> session)
{
    // This is necessary to prolong the life of the old session, otherwise a deadlock happen.
    // This is due to the connectionClose signal in the messageProcessor, which is emitted
    // by ~RemoteSession.
    auto tmpSession = d->session;
    d->certificateVerifier->setSession(session);
    {
        NX_MUTEX_LOCKER lock(&d->mutex);
        d->session = session;
    }
}

nx::Uuid NetworkModule::currentServerId() const
{
    NX_MUTEX_LOCKER lock(&d->mutex);
    if (d->session && d->session->connection())
        return d->session->connection()->moduleInformation().id;

    return nx::Uuid();
}

RemoteConnectionFactory* NetworkModule::connectionFactory() const
{
    return d->connectionFactory.get();
}

void NetworkModule::reinitializeCertificateStorage()
{
    const auto level = appContext()->coreSettings()->certificateValidationLevel();
    d->certificateVerifier->setValidationLevel(level);
    d->connectionCertificatesStorage->reinitialize(level);
    d->autoGeneratedCertificatesStorage->reinitialize(level);
}

} // namespace nx::vms::client::core
